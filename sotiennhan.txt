import telebot
import hashlib
from hashlib import md5
import random
import time
import threading
import requests
import logging
import json
import os
import atexit
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
import datetime
from telebot.types import Message
from telebot import TeleBot

pass #logging.basicConfig(level=logging.INFO)
group_chat_id = -1002229762287
user_balance = {}
admin_users = [6804206350]

# API Key from BotFather
API_KEY = '7119238900:AAGFyewrMSJopccftIPkhLyeOvld2ORE5nA'
API_KEY1 = '7123999803:AAH-Uke4QNURThfQND_Zwarh4h9MdUJcE3M'
bot = telebot.TeleBot(API_KEY, parse_mode=None)
bot2 = telebot.TeleBot(API_KEY1, parse_mode=None)

def save_balance_to_file():
    with open("balance.txt", "w") as f:
        for user_id, balance in user_balance.items():
            balance_int = int(balance)
            f.write(f"{user_id} {balance_int}\n")

def load_balance_from_file():
    if os.path.exists("balance.txt"):
        with open("balance.txt", "r") as f:
            for line in f:
                if line.strip():
                    user_id, balance_str = line.strip().split()
                    balance = float(balance_str)
                    if balance.is_integer():
                        balance = int(balance)
                    user_balance[int(user_id)] = balance


def initialize_user_balance():
    if not user_balance:
        load_balance_from_file()


initialize_user_balance()


def on_exit():
    save_balance_to_file()


atexit.register(on_exit)

# Load or initialize banned users list
def load_banned_users():
    try:
        with open('banned_users.json', 'r') as file:
            return json.load(file)
    except FileNotFoundError:
        return []

banned_users = load_banned_users()

def save_banned_users():
    try:
        with open('banned_users.json', 'w') as file:
            json.dump(banned_users, file)
    except Exception as e:
        pass #logging.error(f"Failed to save banned users: {e}")

def generate_md5_signature(partner_key, code, command, partner_id, request_id, serial, telco):
    signature_string = partner_key + code + command + partner_id + str(request_id) + serial + telco
    md5_hash = hashlib.md5(signature_string.encode()).hexdigest()
    return md5_hash

def read_partner_id():
    try:
        with open('partnerid.txt', 'r') as file:
            partner_id = file.read().strip()
            return partner_id
    except IOError as e:
        pass #logging.error(f"Error reading partner ID from file: {e}")
        return None

def check_ls_api():
    partner_id = read_partner_id()
    if not partner_id:
        pass #logging.error("Partner ID not found. Exiting...")
        return

    while True:
        try:
            params = {
                'partner_id': partner_id,
            }
            response = requests.get('https://thesieure.com/chargingws/price', params=params)

            if response.status_code == 200:
                data = response.json()
                filtered_data = filter_and_format_data(data)
                save_to_file(filtered_data)
            else:
                pass #logging.error(f"{response.status_code}")
                pass #logging.error(f"{response.text}")
        except Exception as e:
            pass #logging.error(f"{e}")
        time.sleep(43200) 

def filter_and_format_data(data):
    providers = ['VIETTEL', 'VINAPHONE', 'MOBIFONE', 'VNMOBI', 'GATE', 'ZING']
    result = {}
    for provider in providers:
        if provider in data:
            result[provider] = []
            for item in data[provider]:
                result[provider].append({
                    'telco': item['telco'],
                    'value': item['value'],
                    'fees': item['fees'],
                    'penalty': item['penalty']
                })
    return result

def save_to_file(data, filename='chietkhau.json'):
    try:
        with open(filename, 'w') as f:
            json.dump(data, f, indent=4)
        pass #logging.info(f"{filename}")
    except IOError as e:
        pass #logging.error(f"{e}")

# Handle /start command
@bot.message_handler(commands=['start'])
def start(message: Message):
    user_id = message.from_user.id
    if is_user_banned(user_id):
        bot.reply_to(message, "B·∫°n ƒë√£ b·ªã banner v√† kh√¥ng th·ªÉ s·ª≠ d·ª•ng bot.")
        return

    username = message.from_user.username
    user_name = message.from_user.first_name
    current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if user_id not in user_balance:
        user_balance[user_id] = 0  
        save_balance_to_file()

    referrer_id = None
    if message.text and message.text.startswith('/start '):
        referrer_id = int(message.text.split()[1])
        save_user_data(referrer_id, user_id)

    admin_message = (
        f"<pre>Th√¥ng tin login c·ªßa ng∆∞·ªùi d√πng\n\n"
        f"User ID: {user_id}\n"
        f"Username: {username}\n"
        f"Name: {user_name}\n"
        f"Time: {current_time}</pre>"
    )
    bot2.send_message(group_chat_id, admin_message, parse_mode='HTML')

    markup = InlineKeyboardMarkup(row_width=2)
    button_cachdung = InlineKeyboardButton('üóí G·∫°ch Th·∫ª C√†o', callback_data='cachdung')
    button_chietkhau = InlineKeyboardButton('üìá Xem Chi·∫øt Kh·∫•u', callback_data='checkchietkhau')
    button_lichsu = InlineKeyboardButton('üìú L·ªãch S·ª≠ ƒê·ªïi Th·∫ª', callback_data='historythe')
    button_gruop = InlineKeyboardButton('üîî K√™nh Th√¥ng B√°o',  url='https://t.me/vankhadev')
    button_taikhoan = InlineKeyboardButton('üë§ T√†i Kho·∫£n', callback_data='taikhoan')
    button_hoahong = InlineKeyboardButton('üçÄ Ki·∫øm Ti·ªÅn', callback_data='show_hoahong')
    markup.add(button_cachdung, button_chietkhau, button_lichsu, button_gruop, button_taikhoan, button_hoahong)

    welcome_message = (
        f'<b>‚óè Ng√†y M·ªõi Vui V·∫ª Nh√© {user_name} ‚òòÔ∏è.\n\n</b>'
        f'<b>‚óè Bot ƒê·ªïi Card Sang Bank Ch√†o B·∫°n.\n\n</b>'
        f'<b>‚óè üëâ M·ªùi b·∫°n ch·ªçn l·ªánh ph√≠a d∆∞·ªõi.\n\n</b>'
    )
    with open('menu.png', 'rb') as photo:
        bot.send_photo(message.chat.id, photo, caption=welcome_message, reply_markup=markup, parse_mode='HTML')

def create_card_buttons():
    try:
        with open('chietkhau.json', 'r') as json_file:
            card_info = json.load(json_file)

        markup = InlineKeyboardMarkup(row_width=2)
        buttons = [InlineKeyboardButton(provider, callback_data=provider) for provider in card_info.keys()]
        for i in range(0, len(buttons), 2):
            markup.add(*buttons[i:i+2])

        return markup
    except FileNotFoundError:
        pass #logging.error("File chietkhau.json kh√¥ng t·ªìn t·∫°i.")
    except Exception as e:
        pass #logging.error(f"{e}")

@bot.callback_query_handler(func=lambda call: call.data == 'checkchietkhau')
def send_card_buttons(call):
    markup = create_card_buttons()
    if markup:
        threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
        bot.send_message(call.message.chat.id, """
<blockquote>B·∫£ng Gi√° Chi·∫øt Kh·∫•u Cho Lo·∫°i Th·∫ª.</blockquote>

<b>C√°ch T√≠nh Gi√° Chi·∫øt Kh·∫•u Th·∫ª C√†o.

T√≠nh ti·ªÅn: (gi√° th·∫ª) - (gi√° th·∫ª x %chi·∫øt kh·∫•u / 100)
.
V√≠ d·ª• th·∫ª 20k : 20000 - (20000x15/100) = 17.000.</b>
 """, reply_markup=markup, parse_mode='HTML')
    else:
        bot.send_message(call.message.chat.id, "Kh√¥ng c√≥ d·ªØ li·ªáu chi·∫øt kh·∫•u ƒë·ªÉ hi·ªÉn th·ªã.")

@bot.callback_query_handler(func=lambda call: call.data in ['VIETTEL', 'VINAPHONE', 'MOBIFONE', 'VNMOBI', 'GATE', 'ZING'])
def callback_query_card_info(call):
    markup = InlineKeyboardMarkup(row_width=1)
    button_back = InlineKeyboardButton('üëâ Quay l·∫°i', callback_data='go_back')
    markup.add(button_back)
    try:
        with open('chietkhau.json', 'r') as json_file:
            card_info = json.load(json_file)

        selected_provider = card_info.get(call.data, None)
        if selected_provider:
            response_message = f"<blockquote>Danh s√°ch gi√° v√† chi·∫øt kh·∫•u cho {call.data}</blockquote>\n\n"
            for item in selected_provider:
                user_fees = item['fees'] + 1.30
                response_message += f"<b>Gi√° tr·ªã: {item['value']:,} VND | Ph√≠: {user_fees}% | Ph·∫°t: {item['penalty']}%</b>\n"
            threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
            bot.send_message(call.message.chat.id, response_message, reply_markup=markup, parse_mode='HTML')
        else:
            bot.send_message(call.message.chat.id, "Kh√¥ng t√¨m th·∫•y th√¥ng tin chi·∫øt kh·∫•u cho th·∫ª c√†o n√†y.")
    except FileNotFoundError:
        bot.send_message(call.message.chat.id, "D·ªØ li·ªáu chi·∫øt kh·∫•u ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t.")
    except Exception as e:
        pass #logging.error(f"Error: {e}")
        bot.send_message(call.message.chat.id, "C√≥ l·ªói x·∫£y ra khi l·∫•y d·ªØ li·ªáu chi·∫øt kh·∫•u.")

@bot.message_handler(commands=['gt'])
def handle_gt_command(message: Message):
    user_id = message.from_user.id
    if is_user_banned(user_id):
        bot.reply_to(message, "B·∫°n ƒë√£ b·ªã banner v√† kh√¥ng th·ªÉ s·ª≠ d·ª•ng bot.")
        return

    try:
        parts = message.text.split()
        if len(parts) != 5:
            bot.reply_to(message, "ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá. C√°ch s·ª≠ d·ª•ng: /gt [t√™n th·∫ª] [m√£ code] [m√£ seri] [m·ªánh gi√°]")
            return

        telco = parts[1]
        code = parts[2]
        serial = parts[3]
        amount = parts[4]

        partner_key = '9703bcd87baa9b4227b337d66c99818c'
        partner_id = '40974027169'
        command = 'charging'
        request_id = random.randint(100000000, 999999999)

        sign = generate_md5_signature(partner_key, code, command, partner_id, request_id, serial, telco)

        headers = {
            'Content-Type': 'application/json',
        }

        data = {
            'telco': telco,
            'code': code,
            'serial': serial,
            'amount': amount,
            'request_id': request_id,
            'partner_id': partner_id,
            'sign': sign,
            'command': command,
        }

        response = requests.post('https://thesieure.com/chargingws/v2', headers=headers, json=data)
        response_data = response.json()
        user_id = message.from_user.id
        response_data['user_id'] = user_id
        response_data['sign'] = sign

        if response.status_code == 200:
            status = response_data.get('status')
            if status == 99:
                with open('lsdoithecao.json', 'a') as f:
                    json.dump(response_data, f, indent=4)
                    f.write('\n')
                bot.reply_to(message, "ƒê·ªïi th·∫ª h·ª£p l·ªá. Vui l√≤ng ch·ªù h·ªá th·ªëng x·ª≠ l√Ω.")
            elif status == 2:
                bot.reply_to(message, "Th·∫ª sai m·ªánh gi√°. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            elif status == 3:
                bot.reply_to(message, "Th·∫ª l·ªói. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            elif status == 4:
                bot.reply_to(message, "B·∫£o tr√¨. Vui l√≤ng th·ª≠ l·∫°i sau.")
        else:
            bot.reply_to(message, f"Vui l√≤ng li√™n h·ªá admin. {response_data.get('message', 'Unknown error')}")

    except Exception as e:
        pass #logging.error(f"{e}")
        bot.reply_to(message, "ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.")

def check_card_status():
    with open('lsdoithecao.json', 'r') as file:
        data = json.load(file)


    partner_key = '9703bcd87baa9b4227b337d66c99818c'
    code = data.get('code')
    command = 'check'
    partner_id = '40974027169'
    request_id = data.get('request_id')
    serial = data.get('serial')
    telco = data.get('telco')
    declared_value = data.get('declared_value')
    user_id = data.get('user_id')

    sign = generate_md5_signature(partner_key, code, command, partner_id, request_id, serial, telco)

    headers = {
        'Content-Type': 'application/json',
    }

    data = {
        'telco': telco,
        'code': code,
        'serial': serial,
        'amount': declared_value,
        'request_id': request_id,
        'partner_id': partner_id,
        'sign': sign,
        'command': command,
    }

    response = requests.post('https://thesieure.com/chargingws/v2', headers=headers, json=data)
    user_id = data.get('user_id')

    if response.status_code == 200:
        response_data = response.json()
        status = response_data.get('status', None)
        message_to_user = "Th·∫ª ·∫¢o"
        if status == 1:
            message_to_user = "Th·∫ª ƒê√∫ng"
        elif status == 2:
            pass #logging.error(f"Status check failed with status code: {status}")
            message_to_user = "Th·∫ª sai m·ªánh gi√°"
        elif status == 3:
            pass #logging.error(f"Status check failed with status code: {status}")
            message_to_user = "Th·∫ª l·ªói"
        elif status == 4:
            pass #logging.error(f"Status check failed with status code: {status}")
            message_to_user = "B·∫£o tr√¨"
        else:
            pass #logging.error(f"Unexpected status code: {status}")

        logging.error(json.dumps({
            "trans_id": response_data.get("trans_id"),
            "request_id": request_id,
            "status": status,
            "message": response_data.get("message", "Unknown error"),
            "telco": telco,
            "code": code,
            "serial": serial,
            "declared_value": declared_value,
            "value": response_data.get("value", 0),
            "amount": response_data.get("amount", 0),
            "callback_sign": response_data.get("callback_sign")
        }, indent=4))

        with open('lsdoithecao.json', 'r') as file:
            user_data = json.load(file)

        transaction = {
            "status": message_to_user,
            "trans_id": response_data.get("trans_id"),
            "user_id": user_data.get("user_id"),
            "request_id": request_id,
            "telco": telco,
            "code": code,
            "serial": serial,
            "declared_value": declared_value,
            "trangthai": status,
            "tratien": response_data.get("amount"),
            "message": response_data.get("message", "Unknown error")
        }

        if save_to_history(transaction):
            time.sleep(20)
            clear_lsdoithecao()
            check_and_reward_user()

        if user_data.get("user_id"):
            hi = user_data.get("user_id")
            balance = user_balance.get(user_data.get("user_id"), 0)
            rounded_balance = round(balance)
            bot.send_message(user_data.get("user_id"), f"<pre>Th√¥ng Tin G·∫°ch Th·∫ª C√†o\nM√£ Trans ID: {response_data.get('trans_id')}\nT√™n th·∫ª : {telco}\nCode: {code}\nSerial: {serial}\nM·ªánh Gi√°: {declared_value}\nTr·∫°ng th√°i: {message_to_user}\nS·ªë ti·ªÅn c·∫≠p nh·∫•t m·ªõi: {round(rounded_balance):,}</pre>", reply_markup=markup123, parse_mode='HTML')
            bot2.send_message(
                group_chat_id,
                f"<pre>Th√¥ng tin giao d·ªãch th·∫ª c√†o:\n\nUID G·∫°ch: {hi}\nTrans ID: {response_data.get('trans_id')}\nT√™n th·∫ª: {telco}\nCode: {code}\nSerial: {serial}\nM·ªánh Gi√°: {declared_value}\nTr·∫°ng th√°i: {message_to_user}\n</pre>", parse_mode='HTML'
            )
        else:
            pass #logging.error(f"Failed to check card status: {response.status_code}")


markup123 = InlineKeyboardMarkup(row_width=2)
button_lichsuthe = InlineKeyboardButton('Xem l·ªãch s·ª≠ th·∫ª', callback_data='historythe')
markup123.add(button_lichsuthe)

def save_to_history(transaction):
    try:
        with open('history.json', 'a') as history_file:
            json.dump(transaction, history_file)
            history_file.write('\n')
        return True
    except Exception as e:
        pass #logging.error(f"Failed to save to history.json: {e}")
        return False

def clear_lsdoithecao():
    try:
        with open('lsdoithecao.json', 'w') as file:
            file.write('')
    except Exception as e:
        pass #logging.error(f"Failed to clear lsdoithecao.json: {e}")

def load_user_balances():
    if os.path.exists("balance.txt"):
        with open("balance.txt", "r") as f:
            for line in f:
                user_id, balance = line.strip().split()
                user_balance[int(user_id)] = float(balance)

def save_user_balances():
    with open("balance.txt", "w") as f:
        for user_id, balance in user_balance.items():
            rounded_balance = round(balance)
            f.write(f"{user_id} {rounded_balance}\n")

def load_processed_transactions():
    if os.path.exists("datathecao.json"):
        with open("datathecao.json", "r") as f:
            return json.load(f)
    return []

def save_processed_transactions(processed_transactions):
    with open("datathecao.json", "w") as f:
        json.dump(processed_transactions, f, indent=4)

def check_and_reward_user():
    reward_percentage = 0.987  # t·ªâ l·ªá %
    processed_transactions = load_processed_transactions()

    try:
        if os.path.exists('history.json'):
            with open('history.json', 'r') as history_file:
                transactions = history_file.readlines()
                for transaction in transactions:
                    data = json.loads(transaction)
                    user_id = data.get('user_id')
                    trans_id = data.get('trans_id')
                    if data.get('trangthai') == 1:
                        if not any(pt['trans_id'] == trans_id and pt['user_id'] == user_id for pt in processed_transactions):
                            reward_amount = data.get('tratien') * reward_percentage
                            reward_amount = round(reward_amount, 2)

                            if user_id in user_balance:
                                user_balance[user_id] += reward_amount
                            else:
                                user_balance[user_id] = reward_amount

                            save_user_balances()

                            processed_transactions.append({'user_id': user_id, 'trans_id': trans_id})

                            pass #print(f"User {user_id} rewarded with {reward_amount}, new balance: {user_balance[user_id]}")
                        else:
                            pass #print(f"Transaction {trans_id} for user {user_id} has already been processed.")

            save_processed_transactions(processed_transactions)

    except Exception as e:
        pass #print(f"Error processing transactions: {e}")

def remove_duplicate_transactions():
    try:
        with open('history.json', 'r') as history_file:
            transactions = history_file.readlines()

        unique_transactions = []
        seen = set()

        for transaction in transactions:
            data = json.loads(transaction)
            identifier = (data['trans_id'], data['code'], data['serial'])
            if identifier not in seen:
                seen.add(identifier)
                unique_transactions.append(transaction)

        with open('history.json', 'w') as history_file:
            for transaction in unique_transactions:
                history_file.write(transaction)

        pass #print("Duplicate transactions removed successfully.")
    except Exception as e:
        pass #print(f"Error removing duplicate transactions: {e}")

def check_card_api():
    while True:
        try:
            check_card_status()
            check_commissions()
            time.sleep(3)
            load_user_balances()
            remove_duplicate_transactions()
        except Exception as e:
            pass #logging.error(f"{e}")
        time.sleep(60)

@bot.callback_query_handler(func=lambda call: call.data == 'historythe')
def show_history_the(call):
    user_id = call.from_user.id
    try:
        with open('history.json', 'r') as history_file:
            lines = history_file.readlines()

        if not lines:
            bot.send_message(call.message.chat.id, "Kh√¥ng t√¨m th·∫•y l·ªãch s·ª≠.")
            return

        message = "<blockquote>Th√¥ng Tin L·ªãch S·ª≠ Th·∫ª C√†o ƒê√£ G·∫°ch</blockquote>\n\n"
        filtered_records = [line for line in lines if json.loads(line).get('user_id') == user_id]
        message += "<b>Th·ª© T·ª± | Tr·∫°ng Th√°i | M√£ TransID | Ng∆∞·ªùi G·∫°ch Th·∫ª | Request ID | T√™n Th·∫ª | M·ªánh Gi√° | M√£ n·∫°p | Serial</b>\n\n"
        markup = InlineKeyboardMarkup(row_width=1)
        button_back = InlineKeyboardButton('üëâ Quay l·∫°i', callback_data='go_back')
        markup.add(button_back)

        if not filtered_records:
            bot.send_message(call.message.chat.id, "Kh√¥ng t√¨m th·∫•y l·ªãch s·ª≠.")
            return

        for index, line in enumerate(lines, start=1):
            record = json.loads(line.strip())
            formatted_record = (f"[{index}] | {record.get('status')} | "
                                f"{record.get('trans_id')} | "
                                f"{record.get('user_id')} | "
                                f"{record.get('request_id')} | "
                                f"{record.get('telco')} | "
                                f"{record.get('declared_value')} | "
                                f"{record.get('code')} | "
                                f"{record.get('serial')}")
            message += formatted_record + "\n\n"

        threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
        bot.send_message(call.message.chat.id, message, reply_markup=markup, parse_mode='HTML')

    except Exception as e:
        pass #logging.error(f"Failed to read history: {e}")
        bot.send_message(call.message.chat.id, "Kh√¥ng th·ªÉ l·∫•y ƒë∆∞·ª£c l·ªãch s·ª≠.")

@bot.callback_query_handler(func=lambda call: call.data == 'cachdung')
def show_cachdung(call):
   markup = InlineKeyboardMarkup(row_width=1)
   button_back = InlineKeyboardButton('üëâ Quay l·∫°i', callback_data='go_back')
   markup.add(button_back)

   message_content = (
       "<blockquote>H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng G·∫°ch Th·∫ª C√†o Sang ATM</blockquote>\n\n"
       "<b>L·ªánh: /gt [t√™n th·∫ª] [m√£ code] [m√£ seri] [m·ªánh gi√°]</b>\n\n"
       "<b>T√™n Th·∫ª C√†o: VIETTEL, VINAPHONE, MOBIFONE, VNMOBI, GATE, ZING [H·ª£p L·ªá]</b>\n\n"
       "<b>V√≠ d·ª•: /gt VIETTEL 0000000000000 111111111111 100000</b>\n\n"
       "<b>Khi G·∫°ch Xong Th·∫ª S·∫Ω G·ª≠i Cho H·ªá Th·ªëng X√©t Duy·ªát</b>\n\n"
       "<b>Sau Khi X√©t Duy·ªát Xong Bot S·∫Ω Th√¥ng B√°o Th·∫ª ƒê√∫ng Hay L·ªói Cho M·ªçi Ng∆∞·ªùi</b>\n\n"
       "<b>Vui L√≤ng Kh√¥ng Spam Th·∫ª ·∫¢o Ch√∫ng T√¥i S·∫Ω BANNER B·∫°n M√£i M√£i</b>\n\n"
   )
   threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
   bot.send_message(call.message.chat.id, message_content, reply_markup=markup, parse_mode='HTML')


@bot.callback_query_handler(func=lambda call: call.data == 'taikhoan')
def show_taikhoan(call):
   markup = InlineKeyboardMarkup(row_width=2)
   button_ruttien = InlineKeyboardButton('üí∏ R√∫t Ti·ªÅn', callback_data='ruttien')
   button_blance = InlineKeyboardButton('üí∞ Xem S·ªë D∆∞', callback_data='sodu')
   button_chuyenkhoan = InlineKeyboardButton('üé≠ Chuy·ªÉn Kho·∫£n', callback_data='chuyen_tien')
   button_history = InlineKeyboardButton('üå† L·ªãch S·ª≠ R√∫t', callback_data='show_history')
   button_back = InlineKeyboardButton('üëâ Quay l·∫°i', callback_data='go_back')
   markup.add(button_ruttien, button_blance, button_chuyenkhoan, button_history, button_back)
   time.sleep(1)

   message_content = (
         "<blockquote>Th√¥ng Tin T√†i Kho·∫£n</blockquote>\n\n"
       )

   bot.send_message(call.message.chat.id, message_content, reply_markup=markup, parse_mode='HTML')
   threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()

@bot.callback_query_handler(func=lambda call: call.data == 'sodu')
def show_sodu(call):
   user_id = call.from_user.id
   balance = user_balance.get(user_id, 0)
   rounded_balance = round(balance)
   username = call.from_user.username
   user_name = call.from_user.first_name
   markup = InlineKeyboardMarkup(row_width=1)
   button_back = InlineKeyboardButton('üëâ Quay l·∫°i', callback_data='go_back')
   markup.add(button_back)

   message_content = (
       f"<b>Uid Account: {user_id}</b>\n\n"
       f"<b>@Account: {username}</b>\n\n"
       f"<b>T√™n Account: {user_name}</b>\n\n"
       f"<b>S·ªë Ti·ªÅn Hi·ªán C√≥: {rounded_balance:,}</b>\n\n"
   )
   threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
   bot.send_message(call.message.chat.id, message_content, reply_markup=markup, parse_mode='HTML')

@bot.callback_query_handler(func=lambda call: call.data == 'ruttien')
def show_ruttien(call):
   user_id = call.from_user.id
   balance = user_balance.get(user_id, 0)
   rounded_balance = round(balance)
   markup = InlineKeyboardMarkup(row_width=2)
   button_momo = InlineKeyboardButton('Momo', callback_data='rutmomo')
   button_bank = InlineKeyboardButton('Bank', callback_data='rutbank')
   button_back = InlineKeyboardButton('üëâ Quay l·∫°i', callback_data='go_back')
   markup.add(button_momo, button_bank, button_back)

   message_content = (
       f"<blockquote>Ch·ªçn ph∆∞∆°ng th·ª©c r√∫t ti·ªÅn</blockquote>\n"
       f"<b>S·ªë ti·∫øn c√≤n l·∫°i: {rounded_balance:,}</b>\n\n"
   )
   threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
   bot.send_message(call.message.chat.id, message_content, reply_markup=markup, parse_mode='HTML')

markup1 = InlineKeyboardMarkup(row_width=1)
button_back = InlineKeyboardButton('üëâ Quay l·∫°i', callback_data='go_back')
markup1.add(button_back)
@bot.callback_query_handler(func=lambda call: call.data == 'chuyen_tien')
def show_chuyen_tien(call):
    threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
    bot.send_message(
        call.message.chat.id, f'''
<blockquote>Vui L√≤ng Th·ª±c Hi·ªán Theo H∆∞·ªõng D·∫´n Sau:</blockquote>

<b>/ct[d·∫•u c√°ch]Uid[d·∫•u c√°ch]S·ªë ti·ªÅn</b>

<b>V√≠ D·ª•: /ct 5404649016 100000</b>

<b>Ph√≠ chuy·ªÉn ti·ªÅn l√† 1% ƒë∆∞·ª£c tr·ª´ v√†o t√†i kho·∫£n ng∆∞·ªùi chuy·ªÉn</b>
''', reply_markup=markup1, parse_mode='HTML')

@bot.callback_query_handler(func=lambda call: call.data == 'rutbank')
def show_rutbank(call):
    threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
    bot.send_message(
        call.message.chat.id, f'''
<blockquote>Vui L√≤ng Th·ª±c Hi·ªán Theo H∆∞·ªõng D·∫´n Sau:</blockquote>

<b>/rutbank[d·∫•u c√°ch]t√™n ng√¢n h√†ng[d·∫•u c√°ch]s·ªë t√†i kho·∫£n[d·∫•u c√°ch]ch·ªß t√†i kho·∫£n[d·∫•u c√°ch]s·ªë ti·ªÅn</b>

<b>V√≠ D·ª•: /rutbank MBank 0345550985 PHAN VAN KHA 100000</b>

<b>Min R√∫t: 10.000k Max R√∫t: 50.000.000k [Ph√≠ r√∫t: 1,000]</b>
''', reply_markup=markup1, parse_mode='HTML')

@bot.callback_query_handler(func=lambda call: call.data == 'rutmomo')
def show_rutmomo(call):
    threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
    bot.send_message(
        call.message.chat.id, f'''
<blockquote>Vui L√≤ng Th·ª±c Hi·ªán Theo H∆∞·ªõng D·∫´n Sau:</blockquote>

<b>/rutmomo[d·∫•u c√°ch]s·ªë t√†i kho·∫£n[d·∫•u c√°ch]s·ªë ti·ªÅn</b>

<b>V√≠ D·ª•: /rutmomo 0345550985 100000</b>

<b>Min R√∫t: 10.000k Max R√∫t: 50.000.000k [Ph√≠ r√∫t: 1,000]</b>
''', reply_markup=markup1, parse_mode='HTML')

@bot.message_handler(commands=['ct'])
def chuyentien(message):
    try:
        parts = message.text.split()
        if len(parts) != 3:
            bot.reply_to(
                message,
                "Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng: /ct[d·∫•u c√°ch]Uid[d·∫•u c√°ch]S·ªë ti·ªÅn"
            )
            return

        recipient_id = int(parts[1])
        amount = float(parts[2])

        sender_id = message.from_user.id
        if sender_id not in user_balance:
            bot.reply_to(message,
                         "S·ªë d∆∞ c·ªßa b·∫°n kh√¥ng ƒë·ªß ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch.")
            return

        sender_balance = user_balance[sender_id]
        if amount > sender_balance:
            bot.reply_to(message,
                         "S·ªë d∆∞ c·ªßa b·∫°n kh√¥ng ƒë·ªß ƒë·ªÉ th·ª±c hi·ªán giao d·ªãch.")
            return

        transfer_fee = amount * 0.01
        net_transfer_amount = amount - transfer_fee

        user_balance[sender_id] -= amount
        user_balance[recipient_id] = user_balance.get(recipient_id, 0) + net_transfer_amount

        if recipient_id not in user_balance:
            user_balance[recipient_id] = 0
        user_balance[recipient_id] += net_transfer_amount

        save_balance_to_file()

        net_transfer_amount = int(net_transfer_amount)
        sender_formatted_balance = '{:,.0f} VNƒê'.format(user_balance[sender_id])
        recipient_formatted_balance = '{:,.0f} VNƒê'.format(user_balance[recipient_id])
        bot.send_message(
            sender_id,
            f"<pre>B·∫°n ƒê√£ Chuy·ªÉn: {net_transfer_amount:,.0f} Cho Ng∆∞·ªùi D√πng.\nC√≥ ID: {recipient_id} Th√†nh C√¥ng.\nS·ªë d∆∞ m·ªõi c·ªßa b·∫°n: {sender_formatted_balance}\n\nPh√≠ Chuy·ªÉn 1% S·∫Ω Tr·ª´ V√†o V√≠ C·ªßa B·∫°n.</pre>", parse_mode='HTML'
        )
        bot.send_message(
            recipient_id,
            f"<pre>B·∫°n ƒê√£ Nh·∫≠n ƒê∆∞·ª£c {net_transfer_amount:,.0f} T·ª´ Ng∆∞·ªùi Ch∆°i C√≥ ID {sender_id}.\nS·ªë D∆∞ M·ªõi C·ªßa B·∫°n: {recipient_formatted_balance}</pre>", parse_mode='HTML'
        )

        group_message = f"<b>Ng∆∞·ªùi d√πng c√≥ ID {sender_id} ƒë√£ chuy·ªÉn {net_transfer_amount:,.0f} VNƒê cho ng∆∞·ªùi d√πng c√≥ ID {recipient_id}.</b>"
        bot2.send_message(chat_id=group_chat_id, text=group_message, parse_mode="HTML")

    except ValueError:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn l√† m·ªôt s·ªë h·ª£p l·ªá.")

@bot.message_handler(commands=['rutbank'])
def handle_ruttien(message):
    try:
        command_parts = message.text.split()[1:]
        if len(command_parts) != 4:
            bot.reply_to(
                message,
                "Sai c√∫ ph√°p. Vui l√≤ng s·ª≠ d·ª•ng /rutbank [t√™n ng√¢n h√†ng] [s·ªë t√†i kho·∫£n] [ch·ªß t√†i kho·∫£n] [s·ªë ti·ªÅn]"
            )
            return

        bank_name = command_parts[0]
        account_number = command_parts[1]
        account_holder = command_parts[2]
        amount = float(command_parts[3])

        withdrawal_fee = 1000
        total_amount_needed = amount + withdrawal_fee

        if amount < 10000:
            bot.reply_to(message,
                         "S·ªë ti·ªÅn r√∫t t·ª´ Bank ph·∫£i √≠t nh·∫•t l√† 10,000 VNƒê.")
            return

        user_id = message.from_user.id
        if user_id not in user_balance:
            bot.reply_to(message,
                         "B·∫°n ch∆∞a c√≥ s·ªë d∆∞ trong t√†i kho·∫£n c·ªßa m√¨nh.")
            return

        if user_balance[user_id] < total_amount_needed:
            bot.reply_to(message, "S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ r√∫t ti·ªÅn.")
            return

        user_balance[user_id] -= total_amount_needed
        save_balance_to_file()

        amount_str = '{:,.0f}'.format(amount).replace(',', '.')
        encoded_amount_str = '{:,.0f}'.format(amount).replace('.', ',')

        bot.reply_to(
            message,
            f"<b>B·∫°n T·∫°o ƒê∆°n R√∫t Ti·ªÅn Th√†nh C√¥ng, Vui L√≤ng Ch·ªù X√©t Duy·ªát.\nS·ªë ti·ªÅn r√∫t: {amount_str}\nNg√¢n h√†ng: {bank_name}\nS·ªë t√†i kho·∫£n: {account_number}\nCh·ªß t√†i kho·∫£n: {account_holder}</b>", parse_mode='HTML'
        )

        markup = InlineKeyboardMarkup()
        button_success = InlineKeyboardButton('Th√†nh C√¥ng', callback_data=f'success_bank_{user_id}_{amount_str}_{bank_name}_{account_number}_{account_holder}')
        button_failure = InlineKeyboardButton('Th·∫•t B·∫°i', callback_data=f'failure_bank_{user_id}_{amount_str}_{bank_name}_{account_number}_{account_holder}')
        markup.add(button_success, button_failure)

        bot.send_message(
            group_chat_id,
            f"<pre>Ng∆∞·ªùi d√πng {user_id}\nƒê√£ r√∫t ti·ªÅn t·ª´ Bank.\nS·ªë ti·ªÅn: {amount_str}\nNg√¢n h√†ng: {bank_name}\nS·ªë t√†i kho·∫£n: {account_number}\nCh·ªß t√†i kho·∫£n: {account_holder}</pre>",
            reply_markup=markup,
            parse_mode='HTML'
        )

    except Exception as e:
        bot.reply_to(message, "ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.")
        pass #logging.error(f"Error handling /rutbank: {e}")

@bot.message_handler(commands=['rutmomo'])
def handle_rutmomo(message):
    try:
        command_parts = message.text.split()[1:]
        if len(command_parts) != 2:
            bot.reply_to(
                message,
                "Sai c√∫ ph√°p. Vui l√≤ng s·ª≠ d·ª•ng /rutmomo [SƒêT] [s·ªë ti·ªÅn]"
            )
            return

        phone_number = command_parts[0]
        if not phone_number.isdigit() or len(phone_number) != 10:
            bot.reply_to(message, "S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p l·∫°i.")
            return

        try:
            amount_str = command_parts[1].replace(',', '').replace('.', '')
            amount = float(amount_str)
        except ValueError as ve:
            logging.error(f"ValueError when converting amount: {ve}")
            bot.reply_to(message, "S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p l·∫°i.")
            return

        if amount < 10000:
            bot.reply_to(message, "S·ªë ti·ªÅn r√∫t t·ª´ Momo ph·∫£i √≠t nh·∫•t l√† 10,000 VNƒê.")
            return

        user_id = message.from_user.id
        if user_id not in user_balance:
            bot.reply_to(message, "B·∫°n ch∆∞a c√≥ s·ªë d∆∞ trong t√†i kho·∫£n c·ªßa m√¨nh.")
            return

        withdrawal_fee = 1000
        total_amount_needed = amount + withdrawal_fee

        if user_balance[user_id] < total_amount_needed:
            bot.reply_to(message, "S·ªë d∆∞ kh√¥ng ƒë·ªß ƒë·ªÉ r√∫t ti·ªÅn.")
            return

        user_balance[user_id] -= total_amount_needed
        save_balance_to_file()

        amount_formatted = '{:,.0f}'.format(amount).replace(',', '.')

        bot.reply_to(
            message,
            f"<b>B·∫°n T·∫°o ƒê∆°n R√∫t Ti·ªÅn Th√†nh C√¥ng, Vui L√≤ng Ch·ªù X√©t Duy·ªát.\nS·ªë ti·ªÅn: {amount_formatted}\nS·ªë ƒëi·ªán tho·∫°i: {phone_number}</b>",
            parse_mode='HTML'
        )

        markup = InlineKeyboardMarkup()
        button_success = InlineKeyboardButton('Th√†nh C√¥ng', callback_data=f'success_momo_{user_id}_{amount_formatted}_{phone_number}')
        button_failure = InlineKeyboardButton('Th·∫•t B·∫°i', callback_data=f'failure_momo_{user_id}_{amount_formatted}_{phone_number}')
        markup.add(button_success, button_failure)

        bot.send_message(
            group_chat_id,
            f"<pre>Ng∆∞·ªùi d√πng {user_id}\nƒê√£ r√∫t ti·ªÅn qua Momo.\nS·ªë ti·ªÅn: {amount_formatted}\nS·ªë ƒëi·ªán tho·∫°i: {phone_number}</pre>",
            reply_markup=markup,
            parse_mode='HTML'
        )

    except Exception as e:
        pass #logging.error(f"{e}")
        bot.reply_to(message, "ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.")

@bot.callback_query_handler(func=lambda call: call.data.startswith('success_') or call.data.startswith('failure_'))
def handle_callback(call):
    try:
        data = call.data.split('_')
        action = data[0]
        method = data[1]
        user_id = int(data[2])
        amount_formatted = data[3].replace('.', '').replace(',', '')
        amount = float(amount_formatted)

        if method == 'momo':
            phone_number = data[4]
            detail = f"{phone_number}"
            with open('historyrut.txt', 'a') as file:
                status = "Th√†nh C√¥ng" if action == 'success' else "Th·∫•t B·∫°i"
                file.write(f"{status} | MOMO | {user_id} | {amount_formatted} | {detail}\n")
        elif method == 'bank':
            bank_name = data[4]
            account_number = data[5]
            account_holder = data[6]
            detail = f"{account_number} | {account_holder}"
            with open('historyrut.txt', 'a') as file:
                status = "Th√†nh C√¥ng" if action == 'success' else "Th·∫•t B·∫°i"
                file.write(f"{status} | {bank_name} | {user_id} | {amount_formatted} | {detail}\n")

        bot.send_message(
            user_id,
            f"{user_id} y√™u c·∫ßu r√∫t ti·ªÅn {method} c·ªßa b·∫°n ƒë√£ {status.lower()}."
        , reply_markup=markup1)

        threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()

    except Exception as e:
        bot.answer_callback_query(call.id, f"ƒê√£ x·∫£y ra l·ªói {e}")
        pass #logging.error(f"L·ªói: {e}")


@bot.message_handler(commands=['banner'])
def handle_banner_command(message: Message):
    try:
        user_id = message.from_user.id
        if user_id not in admin_users:
            bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
            return

        parts = message.text.split()
        if len(parts) != 2:
            bot.reply_to(message, "ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá. C√°ch s·ª≠ d·ª•ng: /banner uid")
            return

        uid = int(parts[1])
        if uid not in banned_users:
            banned_users.append(uid)
            save_banned_users()
            bot.send_message(uid, "B·∫°n ƒë√£ b·ªã banner v√† kh√¥ng th·ªÉ s·ª≠ d·ª•ng bot.")
            bot.reply_to(message, f"ƒê√£ banner ng∆∞·ªùi d√πng v·ªõi UID: {uid}")
        else:
            bot.reply_to(message, f"Ng∆∞·ªùi d√πng v·ªõi UID: {uid} ƒë√£ b·ªã banner t·ª´ tr∆∞·ªõc.")
    except Exception as e:
        logging.error(f"Error in handle_banner_command: {e}")
        bot.reply_to(message, "ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n.")

# Function to check if a user is banned
def is_user_banned(user_id):
    return user_id in banned_users

@bot.callback_query_handler(func=lambda call: call.data == 'show_history')
def show_history(call):
    try:
        user_id = call.from_user.id

        with open("historyrut.txt", "r") as history_file:
            user_history = ""
            for line in history_file:
                if str(user_id) in line:
                    user_history += line

        markup = InlineKeyboardMarkup(row_width=2)
        button_back = InlineKeyboardButton('üëâ Quay l·∫°i', callback_data='go_back')
        markup.add(button_back)

        if user_history:
            bot.send_message(
                call.message.chat.id,
                f"<blockquote>Tr·∫°ng Th√°i | Lo·∫°i | UID | S·ªë Ti·ªÅn | Ng√¢n H√†ng | STK | T√™n Ch·ªß TK |</blockquote>\n\n<b>{user_history}</b>"
            , reply_markup=markup, parse_mode='HTML')
        else:
            bot.send_message(call.message.chat.id, "L·ªãch s·ª≠ c·ªßa b·∫°n l√† tr·ªëng.")
    except Exception as e:
        pass #print(str(e))
        bot.send_message(call.message.chat.id, "ƒê√£ x·∫£y ra l·ªói khi l·∫•y l·ªãch")


@bot.callback_query_handler(func=lambda call: call.data == 'show_hoahong')
def show_hoahong(call):
    user_id = call.from_user.id
    threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()

    aff_link = f"https://t.me/thongbaogachthe?start={user_id}"
    short_link = shorten_url(aff_link)

    total_commission = get_total_commission(user_id)

    if short_link:
        bot.send_message(
            call.message.chat.id, f'''
<blockquote>H∆∞·ªõng D·∫´n Ki·∫øm Ti·ªÅn Share Link Nh∆∞ Sau:</blockquote>

<b>M·ªçi ng∆∞·ªùi copy link gi·ªõi thi·ªáu v√† g·ª≠i cho ng∆∞·ªùi m·ªõi ch∆∞a t·ª´ng tham gia g·∫°ch th·∫ª c√†o</b>

<b>Link</b>: <code>{short_link}</code>

<b>C√°ch tr·∫£ ti·ªÅn: Ng∆∞·ªùi m·ªõi ƒë√≥ nh·∫•p v√†o link v√† g·∫°ch th·∫ª t·∫°i bot b·∫°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c 5% t·ª´ ng∆∞·ªùi ƒë√≥.</b>

<b>Y√™u c·∫ßu: C√≥ l·ªãch s·ª≠ g·∫°ch tr√™n 50.000 ( ch·ªâ 1 l·∫ßn kh√¥ng t√≠nh th√™m n·∫øu r√∫t l·∫ßn 2.v.v)</b>

<b>S·ªë l∆∞·ª£ng ng∆∞·ªùi ƒë√£ nh·∫•p: </b><tg-spoiler>{len(get_user_clicks(user_id))}</tg-spoiler>

<b>Danh S√°ch Ng∆∞·ªùi Nh·∫•p: </b><tg-spoiler>{get_user_clicks_list(user_id)}</tg-spoiler>

<b>T·ªïng s·ªë ti·ªÅn b·∫°n ƒë√£ nh·∫≠n: </b><tg-spoiler>{round(total_commission):,} VND</tg-spoiler>
''', parse_mode='HTML')
    else:
        bot.send_message(call.message.chat.id, "Xin l·ªói, t√¥i kh√¥ng th·ªÉ r√∫t g·ªçn ƒë∆∞·ªùng link. Vui l√≤ng th·ª≠ l·∫°i sau.")

def get_total_commission(user_id):
    if os.path.exists('sotiennhan.txt'):
        with open('sotiennhan.txt', 'r') as f:
            for line in f:
                uid, total_commission = line.strip().split()
                if int(uid) == user_id:
                    return float(total_commission)
    return 0.0

def shorten_url(url):
  api_url = 'https://cleanuri.com/api/v1/shorten'
  data = {'url': url}
  try:
      response = requests.post(api_url, data=data)
      response.raise_for_status()
      response_data = response.json()
      return response_data.get('result_url')
  except requests.exceptions.RequestException as e:
      pass #print(f"Request failed: {e}")
      return None

def save_user_data(user_id, nguoiclick):
    if user_id == nguoiclick:
        return

    file_path = 'datauserhh.json'
    user_data = {}

    if os.path.exists(file_path):
        with open(file_path, 'r') as f:
            user_data = json.load(f)

    for uid, data in user_data.items():
        if nguoiclick in data["nguoiclick"]:
            return

    user_str = str(user_id)
    if user_str not in user_data:
        user_data[user_str] = {"user": user_id, "nguoiclick": []}

    if nguoiclick not in user_data[user_str]["nguoiclick"]:
        user_data[user_str]["nguoiclick"].append(nguoiclick)
        with open(file_path, 'w') as f:
            json.dump(user_data, f, indent=4)


def get_user_clicks(user_id):
    file_path = 'datauserhh.json'
    if os.path.exists(file_path):
        with open(file_path, 'r') as f:
            user_data = json.load(f)
        user_str = str(user_id)
        if user_str in user_data:
            return user_data[user_str]["nguoiclick"]
    return []

def get_user_clicks_list(user_id):
    clicks = get_user_clicks(user_id)
    if clicks:
        return ', '.join(map(str, clicks))
    return "Ch∆∞a c√≥ ai nh·∫•p v√†o link c·ªßa b·∫°n."

def check_commissions():
    # Load user data
    user_data = {}
    if os.path.exists('datauserhh.json'):
        with open('datauserhh.json', 'r') as f:
            user_data = json.load(f)

    # Load commission history
    commission_history = []
    if os.path.exists('lichsuhoahong.json'):
        with open('lichsuhoahong.json', 'r') as f:
            commission_history = json.load(f)

    commission_history_set = {entry['trans_id'] for entry in commission_history}

    # Process history transactions
    if os.path.exists('history.json'):
        with open('history.json', 'r') as f:
            for line in f:
                transaction = json.loads(line)
                trans_id = transaction['trans_id']
                user_id = transaction['user_id']
                declared_value = transaction['declared_value']
                trangthai = transaction['trangthai']

                if trangthai == 1 and trans_id not in commission_history_set:
                    for user_str, data in user_data.items():
                        if user_id in data['nguoiclick']:
                            user = data['user']
                            commission_amount = declared_value * 0.05
                            user_balance[user] += commission_amount
                            user_commissions[user] = user_commissions.get(user, 0) + commission_amount

                            # Log the commission
                            commission_entry = {
                                'trans_id': trans_id,
                                'user': user,
                                'nguoiclick': user_id
                            }
                            commission_history.append(commission_entry)
                            update_user_commission(user, commission_amount)
                            save_balance_to_file()

    # Save commission history
    with open('lichsuhoahong.json', 'w') as f:
        json.dump(commission_history, f, indent=4)


user_commissions = {}

def update_user_commission(user, commission_amount):
    # Load existing commission data
    commission_data = {}
    if os.path.exists('sotiennhan.txt'):
        with open('sotiennhan.txt', 'r') as f:
            for line in f:
                user_id, total_commission = line.strip().split()
                commission_data[int(user_id)] = float(total_commission)

    # Update commission for the user
    if user in commission_data:
        commission_data[user] += commission_amount
    else:
        commission_data[user] = commission_amount

    # Write the updated commission data back to the file
    with open('sotiennhan.txt', 'w') as f:
        for user_id, total_commission in commission_data.items():
            f.write(f"{user_id} {total_commission:.2f}\n")

@bot.callback_query_handler(func=lambda call: call.data == 'go_back')
def go_back(call):
    threading.Timer(3, lambda: bot.delete_message(call.message.chat.id, call.message.message_id)).start()
    start(call.message)


def run_bot(bot):
    while True:
        try:
            bot.polling(none_stop=True)
        except Exception as e:
            pass #logging.error(f"{e}")
            time.sleep(3)

if __name__ == "__main__":
    thread_ls_api = threading.Thread(target=check_ls_api)
    thread_ls_api1 = threading.Thread(target=check_card_api)

    thread_ls_api.start()
    thread_ls_api1.start()

    bot_thread = threading.Thread(target=run_bot, args=(bot,))
    bot2_thread = threading.Thread(target=run_bot, args=(bot2,))

    bot_thread.start()
    bot2_thread.start()

    thread_ls_api.join()
    thread_ls_api1.join()
    bot_thread.join()
    bot2_thread.join()